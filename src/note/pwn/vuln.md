# Pwn 漏洞与利用

**著名漏洞以及成因**：

1. **缓冲区溢出漏洞**（无限制的写入导致程序栈上原本正常的数据被覆盖）
2. **整数溢出漏洞**（对输入数字的大小进行了错误的判断）
3. **格式化字符串漏洞**（scanf/printf系列函数可自定义格式化字符串）
4. **堆溢出漏洞**（无限制的写入导致堆空间中原本正常的数据被覆盖）
5. **UAF**（野指针）（释放掉动态分配的空间后，未将指针归零，后续又使用该指针）

---

这些漏洞可以用来构造**利用原语**[Exploitation Primitives]：
1. **任意地址读**Arbitrary Read
2. **任意地址写**Arbitrary Write
3. **任意函数调用**Arbitrary Call

任意地址读可以泄露程序的关键信息（程序代码地址，链接库地址，敏感信息...），这些信息配合任意地址写，可以构成任意函数调用。有了这三个原语，程序基本上就处于我们的控制之下了，我们想利用程序完成什么操作，就调用对应函数就可以了。
> 在CTF比赛中，你需要控制程序去读flag文件

针对原语的利用又有不同手法，比如exit_hook，FileStructure，改GOT表...

> 有些漏洞直接就可以拿到任意函数调用原语，比如缓冲区溢出漏洞，可以使用ROP的方式调用函数。有些漏洞不能，比如堆上的漏洞（UAF/堆溢出），通常你需要获取任意地址写之后才能获得任意函数调用

比如说，当你通过覆盖正常的指针，获得了一个任意地址写
> 程序允许你向该指针指向的内容中写数据，本来该指针指向的位置是正常的。在你覆盖它原本的数据为A后，它就指向A。这也就意味着你可以往A处写数据。

并且修改掉了main函数的**返回地址**为B函数地址后，main函数执行完毕返回，就不会回到C标准库了，而是返回到了B函数，并执行B函数的内容。如果B函数是system函数，那么也就意味着，你可以执行任意命令。

---
在理解了程序是如何被破坏的，以及如何被引导完成非法操作之后(不太能理解也没关系)。现在你可以百度搜索或bilibili搜索[pwn入门]开始正式的学习了。但是进阶的知识你就会需要使用谷歌了，百度只能让你入门。


### 下一章节： [Pwn —— 调用约定](./calling_conventions.md)